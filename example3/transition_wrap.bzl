"""
Code copied from rules_meta and modified
"""

load("@rules_meta//meta/internal:forwarding.bzl", "transition_and_forward_providers_factory")


def _wrap_with_transition(
        original_rule,
        transition_rule,
        executable = False,
        test = False,
        **transition_attrs,
    ):
    """Creates a new rule that behaves like an existing rule but also modifies build settings using supplied transition rule

    Args:
        original_rule: The existing rule to wrap (e.g., native.cc_binary).
        transition_rule: Transition rule to apply
        executable: Whether the new rule should be executable (default: False).
        test: Whether the new rule should be a test rule (default: False).
        **transition_attrs: Transition attributes

    Returns:
        A new rule that behaves like the original rule after applying the provided changes to the build settings.
    """
    is_native_rule = str(original_rule).startswith("<built-in rule ")
    native_rule_name = None
    if is_native_rule:
        native_rule_name = str(original_rule)[len("<built-in rule "):-1]

    def _wrapper_macro(name, platforms = "", visibility = None, tags = None, testonly = None, **kwargs):
        unsupported_attr = None
        if is_native_rule:
            if kwargs.get("env") != None and not test:
                unsupported_attr = "env"
            elif kwargs.get("env_inherit") != None:
                unsupported_attr = "env_inherit"

        if unsupported_attr != None:
            fail("Setting the '{unsupported_attr}' attribute of '{native_rule_name}' on the transition wrapper generated by rules_meta is not yet supported.".format(
                unsupported_attr = unsupported_attr,
                native_rule_name = native_rule_name,
            ))

        # Use a subdirectory to preserve the basename but still prevent a name
        # collision with the transition rule.
        orig_name = "{name}/{name}".format(name = name)

        internal_rule_tags = list(tags or [])
        if "manual" not in internal_rule_tags:
            internal_rule_tags.append("manual")

        # Native test rules offer an env attribute that has to be moved to the wrapper.
        wrapper_env = kwargs.pop("env", default = None) if is_native_rule and test else None
        # All executable rules offer an args attribute that has to be moved to the wrapper.
        wrapper_args = kwargs.pop("args", default = None) if (executable or test) else None
        original_rule(
            name = orig_name,
            tags = internal_rule_tags,
            testonly = testonly,
            visibility = ["//visibility:private"],
            **kwargs
        )

        transition_rule(
            name = name,
            args = wrapper_args,
            env = wrapper_env,
            exports = ":" + orig_name,
            tags = tags,
            testonly = testonly,
            visibility = visibility,
            **transition_attrs,
        )

    return _wrapper_macro

meta = struct(
    wrap_with_transition = _wrap_with_transition,
    create_transition_rule = transition_and_forward_providers_factory
)
